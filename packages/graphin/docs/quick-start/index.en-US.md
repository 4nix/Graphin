---
title: Quick start
order: 1
group:
  path: /quick-start
  title: Quick start
  order: 0
nav:
  title: manual
  path: /graphin
  order: 1
---

## 00. Foreword

"Two points and one line constitute a graph", I believe this is a basic understanding of the graph. In our business development, there are often a large number of scenarios that need to visualize the graph. As shown in the figure below, graphs play a key role in different fields.

![Field Relationship Map](https://gw.alipayobjects.com/mdn/rms_402c1a/afts/img/A*G8I1TaPvDogAAAAAAAAAAAAAARQnAQ)

If you also need to visualize the relationship graph, you might as well try the graph visualization tool Graphin launched by AntV~ Next let us follow this online tutorial DEMO to see how Graphin can help us complete a graph analysis application~

> Friendly reminder: This website is generated by dumi, so you can directly click the lower right corner `</>` of the demo example to expand the source code to view.

## 01. Installation dependencies

If you are a web developer using React, then you can use Graphin as a normal React component.

> This article uses yarn to install dependencies, and npm can also be used. The following are the core components of Graphin `@antv/graphin` and analysis components `@antv/graphin-components`, as well as the icon library provided by Graphin`@antv/graphin-icons`

```bash
yarn add @antv/graphin@latest --save
yarn add @antv/graphin-components@latest --save
yarn add @antv/graphin-icons --save
```

## 02. Visualize relational data

The first step to complete a graph analysis product is to visualize relational data. Relational data is a very typical graph structure, consisting of Node and Edge. Only id in Node is a required parameter, and only source and target in Edge are required parameters, which represent the ID of the start node and end node of the edge respectively

<code src='./demos/index.tsx'>

## 03. Visual channel mapping

In the first step, we completed the rendering of the nodes and edges, but their styles are too simple. How to present more information on the nodes and edges? At this time, visual channel mapping can be used. In addition to the regular size, shape, and style, Graphin's built-in nodes and edges are standardized. The built-in node `graphin-circle` is composed of 5 parts of graphics, namely `keyshape`, `label`, `icon`, `badges`, and `halo`, they are all placed in the `style` field of the node, as shown below The `node-0` node shows:

> Note ⚠️: In order to demonstrate the effect, the full configuration files are displayed here. In actual development, we have the `Utils.genDefaultNodeStyle` tool function to help us quickly generate configuration files according to the theme style. At the same time, each node only carries part of the style it needs (Graphin does deepMerge internally with the style of each node)

<code src='./demos/node.tsx'>

Let us continue our case, now `node-0` is a user, `node-1` is an enterprise, and `node-3` is another enterprise. Through the reorganization of the above-mentioned built-in nodes in Graphin, we can use the size of the node to represent the scale of the enterprise, and the ICON of the node to display different attributes and color to distinguish.

- 1. Label each node first
- 2. Map the size of the enterprise `data.count` to the size of the node
- 3. Map the different data types `data.type` to the icon of the node
- 4. `Node-0` is the actual controller behind `Node-2`, which can be mapped as a dotted edge

<code src='./demos/style.tsx'>

## 04. Choose the right layout

In graph visualization, the most attractive thing is the layout. So far, the first layout we have come across is `preset`, which is used to render the x and y position information specified by the user onto the canvas. Imagine the above example, in the real scenario, the data is returned by the server. The amount of data is unknown, and each data does not carry layout information, so we can no longer use `preset` to preset the layout.
At this time, the appropriate layout algorithm is particularly important.
Let's use Graphin's built-in tool function `Utils.mock` to simulate some data and see how the graph visualization displays under different layout algorithms

<code src='./demos/layout.tsx'>

It can be seen that the nodes under the concentric circle algorithm layout can clearly see the central node, which is sorted according to the degree of the node by default. In some gang fraud networks, you can see the key culprits at a glance. The nodes under the directed layering algorithm are arranged hierarchically according to the flow direction of the edges. In some networks with obvious flow directions, such as the capital flow network, the upstream and downstream relationships can be clearly seen.

However, in some general platforms, relational data is not determined from the beginning to determine which layout algorithm to use. At this time, the most convenient way is to provide layout switching capabilities, allowing users to choose independently. Of course, based on the capabilities of AI, we can predict the best layout based on data marking and model training. This part of the ability is under construction

<code src='./demos/layout-switching.tsx'>

## 05. Good interaction can enhance user analysis experience

The data is also rendered and can be correctly laid out. At this time, the product manager came to you and made a request

- The canvas should support zooming, otherwise users will not be able to see the full picture when the amount of data is large
- Click on the node, to have feedback, it is best to make some "delicate" style changes on the node
- When the node Hover goes up, it is best to highlight its associated nodes and edges, so as to reduce visual interference~
- To be able to select nodes in batches, see if you can support mouse circle selection, or draw your own area selection like the magic wand in PS
- ... (100+ optimization suggestions omitted here)

Finally, she praised you again, you are so great, you can definitely experience this picture well~ At this moment, you, suppressing the impulse in your heart, are really a product mouth, development staying up late.

Indeed, good interaction can enhance the user's analytical experience. From this perspective, the product manager is right. Graphin is also a technical product polished from the line of business, so we deconstructed the interaction, encapsulated it into components, and let users introduce it on demand.

```tsx | pure
import { Behaviors } from '@antv/graphin';
const {
  TreeCollapse, // Expand and collapse the tree map
  DragCanvas, // Drag the canvas
  ZoomCanvas, //Zoom canvas
  ClickSelect, // Click to select the node
  BrushSelect, //Circle selection operation
  DragNode, // Drag node
  ResizeCanvas, // automatically adjust canvas width and height
  LassoSelect, // Lasso operation
  DragCombo, // Drag Combo
  ActivateRelations, // associated highlight
  Hoverable, // Hover operation
} = Behaviors;
```

<code src='./demos/behaviors.tsx'>

## 06. Good analysis components can improve user analysis efficiency

With the deepening of business, users have more and more analysis demands. Simple canvas and graphic element operations can no longer satisfy users' analysis demands:

- For example, the operation of nodes is not limited to clicking nodes. It is also necessary to mark nodes, drill down data, delete, and reverse selection. At this time, you need a right-click menu component.
- For example, data classification needs to be marked with contour components or legends

Graphin summarized 26 analysis components according to the guidance in the white paper "AntV Graph Visual Analysis Solution".

<code src='./demos/components.tsx'>

## 07. Precipitating these product solutions, maybe you can use them

If you have the patience to see here, then we can talk about business together. The application of graph visual analysis in different business fields actually has some points in common. For example, in the knowledge graph and financial risk control, there is a core product function, the former is `knowledge reasoning`, the latter is `risk detection`, because in these scenarios, the main use is the data analysis method of drilling down. The special point of drilling down graph data is that it is not only a dynamic process of data, but also a dynamic process of layout. The exploration problem of dynamic graphs is the first business pain point problem solved by the Graphin team. Now we abstract this problem as a combination of two technical solutions of `data-driven + progressive layout`, hoping to help everyone's business.

<code src='./demos/node-expand.tsx'>

In addition to dynamic map layout, large map exploration is also a common requirement in business. Adopting louvain algorithm aggregation, using Combo capability or node aggregation display mode, combined with MiniMap small map navigation, fish-eye magnifying glass, can initially meet the exploration needs of large maps. This piece of [DEMO can refer to](https://antv.vision/graphin-docs/graphin/case/geamaker)

The above is all the content of our quick start: through the fragmentary small DEMO, we have basically seen a basic capability of Graphin:

- Support the rendering of two different data structures: tree map and net map.
- Built-in multiple layouts, support sub-map layout, incremental layout, layout switching.
- There are combination specifications for nodes and edges, and style customization is supported.
- Support the introduction of interactive behavior combinations: Currently, 9 common interaction behaviors have been completed to meet our daily interaction needs.
- Built-in rich analysis components, currently 6 commonly used components have been completed: right-click menu ContexMenu, tooltip, minimap navigation MiniMap, legend component Legend, fisheye magnifier FishEye, contour component Hull. There are 26 components in total.
- Accumulate product functions from business types, such as dynamic map exploration and big map exploration.

If you are still interested, you can continue to read the in-depth exploration part, which will introduce you to Graphin's extension mechanism and component customization mechanism, as well as GraphinStudio that we will focus on next.
